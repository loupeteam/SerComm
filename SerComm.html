<!DOCTYPE html>
<html>
<head>
<title>SerComm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<p><img src="http://automationresourcesgroup.com/images/arglogo254x54.png" alt="Automation Resources Group" /></p>

<h1>SerComm Library</h1>

<p>The SerComm library is an easy to use, fast, and reliable solution for serial communications.</p>

<h1>Usage</h1>

<h2>Initialization</h2>

<p>To use the SerComm functionality, a variable must be declared of type <strong>SerialCommMgr_typ</strong>. The SerialCommMgr uses meaningful default values for configuration settings, but these can be changed if necessary.</p>

<h2>Cyclic Operation</h2>

<p>The <strong>SerialCommFn_Cyclic()</strong> function must be called in the CYCLIC routine of your program once every scan, unconditionally.</p>

<pre><code>SerialCommFn_Cyclic(SerialComm);
</code></pre>

<p>High Throughput Read/Write</p>

<pre><code>//Call manager to open/close
SerialCommMgr(SerialComm);

//Get any data from the driver
SerialCommReceive(SerialComm);

//Do some logic here

//Echo what we received
IF SerialComm.OUT.STAT.NewDataAvailable THEN
    memcpy(ADR(SerialComm.IN.PAR.Data), ADR(SerialComm.OUT.STAT.Data), SerialComm.OUT.STAT.DataLength);
    SerialComm.IN.PAR.DataLength:=  SerialComm.OUT.STAT.DataLength;
    SerialComm.IN.CMD.Send:=        TRUE;
END_IF

//Send any data out
SerialCommSend(SerialComm);

SerialComm.IN.CMD.Send:=        FALSE;
</code></pre>

<p>The communications are enabled by setting <strong>IN.CMD.Enable</strong> to TRUE. Once communications are established, <strong>OUT.STAT.CommunicationActive</strong> is set to TRUE and it is possible to send and receive data.</p>

<pre><code>SerialCommMgr.IN.CMD.Enable:=   1;
</code></pre>

<p>To send data, the data must first be copied into the <strong>IN.PAR.Data</strong> array and <strong>IN.PAR.DataLength</strong> must be set to the number of bytes you wish to send. Then <strong>IN.CMD.Send</strong> must be set to TRUE. Once the data is sent, <strong>OUT.STAT.DataSent</strong> will be set to TRUE and will remain TRUE until <strong>IN.CMD.Send</strong> is reset to FALSE. <strong>IN.PAR.Data</strong> and <strong>IN.PAR.DataLength</strong> are not altered in any way by the <strong>SerialCommFn_Cyclic()</strong> function. So, it is recommended to clear the <strong>IN.PAR.Data</strong> array before copying data into it. Also, be careful to ensure that <strong>IN.PAR.DataLength</strong> is set appropriately.</p>

<pre><code>IF( Send )THEN

    Send:=  0;

    memset( ADR(SerialCommMgr.IN.PAR.Data), 0, SIZEOF(SerialCommMgr.IN.PAR.Data) );
    strcpy( ADR(SerialCommMgr.IN.PAR.Data), ADR('POLL REQUEST') );
    SerialCommMgr.IN.PAR.DataLength:=   strlen( ADR(SerialCommMgr.IN.PAR.Data) );

    SerialCommMgr.IN.CMD.Send:= 1;

END_IF

IF( SerialCommMgr.OUT.STAT.DataSent )THEN
    SerialCommMgr.IN.CMD.Send:= 0;
END_IF
</code></pre>

<p>Any data that is sent to the controller is received automatically. When new data is received, <strong>OUT.STAT.NewDataAvailable</strong> is set to TRUE, <strong>OUT.STAT.DataLength</strong> is set to the length of the received data, and the received data is copied into the <strong>OUT.STAT.Data</strong> array. The received data must be acknowledged by setting <strong>IN.CMD.AcknowledgeData</strong> to TRUE. This will set <strong>OUT.STAT.NewDataAvailable</strong> to FALSE and allow the SerialCommMgr to receive new data. When new data is received, <strong>OUT.STAT.Data</strong> is cleared before copying the new data into the array.</p>

<pre><code>IF( SerialCommMgr.OUT.STAT.NewDataAvailable )THEN

    memset( ADR(ResponseData), 0, SIZEOF(ResponseData) );
    memcpy( ADR(ResponseData), ADR(SerialCommMgr.OUT.STAT.Data), SerialCommMgr.OUT.STAT.DataLength );

    (* Do something with ResponseData *)

    SerialCommMgr.IN.CMD.AcknowledgeData:=  1;

END_IF
</code></pre>

<p>Error information is available in <strong>OUT.STAT.Error</strong>, <strong>OUT.STAT.ErrorID</strong>, and <strong>OUT.STAT.ErrorString</strong>. Error information is cleared by setting <strong>IN.CMD.AcknowledgeError</strong> to TRUE. Some errors require toggling <strong>IN.CMD.Enable</strong> to restore communications.</p>

<h1>Reference</h1>

<h2>SerialCommMgr Data Structure</h2>

<p>The main data structure of the SerComm library is the SerialCommMgr structure (SerialCommMgr_typ datatype). This provides the interface to higher level programs and also stores all necessary internal information. It is divided into inputs (SerialCommMgr.IN), outputs (SerialCommMgr.OUT), and internals (SerialCommMgr.Internal).</p>

<h3>Inputs</h3>

<p>The SerialCommMgr inputs are divided into commands (IN.CMD), parameters (IN.PAR), and configuration settings (IN.CFG). Commands are used to initiate operations, and parameters and configuration settings determine how the commands will be processed. The difference between parameters and configuration settings is that configuration settings are generally set only once, while parameters might be set any time a command is issued.</p>

<h4>Commands</h4>

<ul>
<li><strong>Enable</strong> - Enable the communications driver.</li>
<li><strong>Send</strong> - Send data. Communications must be enabled before sending data.</li>
<li><strong>AcknowledgeData</strong> - Acknowledge received data. Received data must be acknowledge before new data can be received.</li>
<li><strong>AcknowledgeError</strong> - Acknowledge any errors.</li>
</ul>

<h4>Parameters</h4>

<ul>
<li><strong>Data</strong> - Data to be sent.</li>
<li><strong>DataLength</strong> - Length of the data that should be sent.</li>
<li><strong>AllowContinuousSend</strong> - Allows sending every cycle without seeing a FALSE on the send command.</li>
<li><strong>AllowContinuousReceive</strong> - Allows receiving every cycle without seeing an AcknowledgeData command. Data will be overwritten if new data arrives.</li>
</ul>

<h4>Configuration Settings</h4>

<ul>
<li><strong>INADeviceName</strong> - INA device name of the serial interface to use. The default value is 'IF1'.</li>
<li><strong>Mode</strong> - Mode string. The default value is an empty string. This uses the settings defined for the interface in Automation Studio. For details on the mode string, please see the AS online help for the DVFrame library. Please be sure to use the SG4 format and not the SG3 format.</li>
<li><strong>pConfig</strong> - Address of an extended configuration data object of type XOPENCONFIG. For details, please see the AS online help for the DVFrame library.</li>
</ul>

<h3>Outputs</h3>

<p>The SerialCommMgr outputs contain status information (OUT.STAT), including received data.</p>

<ul>
<li><strong>CommunicationActive</strong> - Communication is active. Data can be sent and received.</li>
<li><strong>DataSent</strong> - Data has been sent. This will remain TRUE until <strong>IN.CMD.Send</strong> is reset to FALSE.</li>
<li><strong>NewDataAvailable</strong> - New data has been received and is available in <strong>OUT.STAT.Data</strong>. This will remain TRUE until <strong>IN.CMD.AcknowledgeData</strong> is set to TRUE. Received data must be acknowledged before new data can be received.</li>
<li><strong>Data</strong> - Received data. This is cleared before copying newly received data.</li>
<li><strong>DataLength</strong> - Length of the data received.</li>
<li><strong>Error</strong> - An error is present. <strong>Error</strong> is reset by <strong>IN.CMD.AcknowledgeError</strong>. </li>
<li><strong>ErrorID</strong> - Current error ID number.</li>
<li><strong>ErrorString</strong> - Current error text.</li>
</ul>

<h2>Error ID Numbers</h2>

<ul>
<li>60, 8071-8073, 8078, 8079, 8210, 8251-8258 - These errors are passed along from the internal DVFrame function blocks. These errors are most likely caused by improper configuration information. For details, please see the AS online help for the DVFrame library.</li>
<li>50000 - SERCOMM<em>ERR</em>INVALIDINPUT - The <strong>SerialCommMgrFn_Cyclic()</strong> function was called with an invalid input. Check the function call.</li>
<li>50001 - SERCOMM<em>ERR</em>RECVDATATOOLARGE - The data received did not fit in the <strong>OUT.STAT.Data</strong> array. Only 256 bytes can be received at one time. The first 256 bytes are copied into <strong>OUT.STAT.Data</strong> and <strong>OUT.STAT.DataLength</strong> is set to 256. The remaining bytes are ignored.</li>
<li>50002 - SERCOMM<em>ERR</em>SENDDATATOOLARGE - <strong>IN.PAR.DataLength</strong> is set higher than 256, the maximum number of bytes that can be sent.</li>
</ul>

<h2>Changing the Maximum DataLength</h2>

<p>By default, the maximum length of data that can be sent or received at one time is 256 bytes. If this is not enough data for your application, then <strong>SERCOMM<em>MAI</em>DATA</strong> in the SerComm.var file must be changed. It should be set to one less than the maximum desired data length (e.g. 511 for 512 bytes of data). This also changes the threshold for triggering DATATOOLARGE errors. The library must be recompiled and transfered to the target for this change to take effect. Also, the XOPENCONFIG structure must be used to change the length of the transmit and receive frames used by the frame driver. For details on this, please see the AS online help for the DVFrame library.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
